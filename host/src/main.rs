// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    KIMCHI0_ELF, KIMCHI0_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use kimchi::bench::BenchmarkCtx;
use kimchi::groupmap::BWParameters;
use kimchi::mina_curves::pasta::{Fp, Vesta, VestaParameters};
use kimchi::o1_utils::FieldHelpers;
use kimchi::poly_commitment::evaluation_proof::OpeningProof;
use kimchi::proof::ProverProof;
use kimchi::prover_index::ProverIndex;
use kimchi::verifier_index::VerifierIndex;
use serde::{Deserialize, Deserializer, Serialize};
use serde::de::Error;

#[derive(Serialize, Deserialize)]
struct ContextWithProof {
    index: VerifierIndex<Vesta, OpeningProof<Vesta>>,
    // group_map: BWParameters<VestaParameters>,
    proof: ProverProof<Vesta, OpeningProof<Vesta>>,
    public_input: Vec<Vec<u8>>,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    let ctx = BenchmarkCtx::new(17);
    let (proof, public_input) = ctx.create_proof();

    let ctx_with_proof = ContextWithProof {
        index: ctx.verifier_index,
        proof,
        public_input: public_input.into_iter().map(|x| x.to_bytes()).collect(),
    };

    println!("{}", std::mem::size_of_val(&ctx_with_proof));

    let env = ExecutorEnv::builder().write(&ctx_with_proof).unwrap().build().unwrap();

    println!("proving");

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env, KIMCHI0_ELF).unwrap();

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let _output: ContextWithProof = receipt.journal.decode().unwrap();

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(KIMCHI0_ID).unwrap();
}
